/*
 * VIA University College - School of Technology and Business
 * Software Engineering Program - 3rd Semester Project
 *
 * This work is a part of the academic curriculum for the Software Engineering program at VIA University College.
 * It is intended only for educational and academic purposes.
 *
 * No part of this project may be reproduced or transmitted in any form or by any means,
 * except as permitted by VIA University and the course instructor.
 * All rights reserved by the contributors and VIA University College.
 *
 * Project Name: Unrecorded
 * Author: Sergiu Chirap
 * Year: 2024
 */

package com.unrecorded.database.exceptions;

import com.unrecorded.database.util.LoggerUtil;
import jakarta.persistence.*;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.Serializable;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.UUID;

// TODO: Refactor Class, improve and add utility methods, redesign purpose and implement persistence.
/**
 * Represents an exception that occurs during database-related operations.
 *
 * <p>This exception class extends {@link RuntimeException} to handle and
 * categorize errors that occur during communication or interaction with the database.
 * The exception is enhanced with contextual information, such as the operation type,
 * timestamp, error message, and stack trace.</p>
 *
 * <h2>Features:</h2>
 * <ul>
 *     <li>Automatically logs all thrown exceptions using LoggerUtil ({@link LoggerUtil}).</li>
 *     <li>Provides additional metadata, such as the database operation type and related error details.</li>
 *     <li>Supports persistence of exception information with proper JPA annotations.</li>
 *     <li>Flexible constructors for initializing exceptions with different levels of detail.</li>
 * </ul>
 *
 * <h2>Exception Categorization:</h2>
 * <p>Every exception instance is categorized using the {@link TypeOfDAE} enum to indicate
 * the type of database operation that failed:</p>
 * <ul>
 *     <li>{@link TypeOfDAE#INS}: Errors during data insertions.</li>
 *     <li>{@link TypeOfDAE#UPD}: Errors during data updates.</li>
 *     <li>{@link TypeOfDAE#DEL}: Errors during data deletions.</li>
 *     <li>{@link TypeOfDAE#FND}: Errors during data retrieval operations.</li>
 *     <li>{@link TypeOfDAE#GNL}: General database-related errors.</li>
 * </ul>
 *
 * @author Sergiu Chirap
 * @version 2.0
 * @see RuntimeException
 * @see TypeOfDAE
 * @since PREVIEW
 */
@ApiStatus.Experimental
@Entity
@Table(name = "DAE", schema = "unrecorded")
public class DataAccessException extends RuntimeException implements Serializable {

    /**
     * Represents the prefix used in all error messages generated by instances of {@code DataAccessException}.
     *
     * <p>This prefix is prepended to the reason or cause of the exception to provide a standardized
     * format for logs and reports.
     * It ensures consistency across all exception messages
     * related to database connectivity issues.</p>
     *
     * <p><b>Usage:</b></p>
     * <pre>{@code
     * throw new DataAccessException(TypeOfDAE.INS, MSG_PREFIX + "Unable to save record");
     * }</pre>
     *
     * <p><b>Constant Value:</b></p>
     * {@code "Failure connecting to the database:\n"}
     *
     * @see DataAccessException
     */
    private static final String MSG_PREFIX = "Failure connecting to the database:\n";

    /**
     * Represents the error message used for validation when an exception reason is null or blank.
     *
     * <p>This constant provides clarity in error messages by explicitly defining a message
     * that is displayed when the reason for the exception does not meet the required non-blank
     * validation criteria.</p>
     *
     * <p><b>Usage:</b></p>
     * <pre>{@code
     * if (reason.isBlank()) throw new IllegalArgumentException(INVALID_REASON_MSG);
     * }</pre>
     *
     * <p><b>Constant Value:</b></p>
     * {@code "Reason must not be blank!"}
     *
     * @see DataAccessException#DataAccessException(TypeOfDAE, String)
     */
    private static final String INVALID_REASON_MSG = "Reason must not be blank!";

    /**
     * Represents the error message used when an invalid or unsupported exception type is provided.
     *
     * <p>This constant is used in validation logic to indicate that the provided
     * {@code type} does not map to any value in the {@link TypeOfDAE} enumeration.
     * It ensures developers receive clear messages when supplying unsupported types.</p>
     *
     * <p><b>Usage:</b></p>
     * <pre>{@code
     * throw new IllegalArgumentException(INVALID_TYPE_MSG);
     * }</pre>
     *
     * <p><b>Constant Value:</b></p>
     * {@code "Specified 'Type' does not exist."}
     *
     * @see TypeOfDAE
     */
    private static final String INVALID_TYPE_MSG = "Specified 'Type' does not exist.";

    /**
     * Represents the default zone ID used for determining timestamps during exception handling.
     *
     * <p>This constant is used to define the default time zone for recording timestamps
     * in exceptions.
     * The value is set to {@code CET} (Central European Time),
     * ensuring that all timestamps are consistent across the system unless explicitly overridden.</p>
     *
     * <p><b>Note:</b> This field is marked as {@code @Transient}, meaning it will not be persisted
     * in the database or serialized, as it serves as a runtime utility rather than a persistent property.</p>
     *
     * <p><b>Constant Value:</b></p>
     * {@code ZoneId.of("CET")}
     *
     * <p><b>Example Usage:</b></p>
     * <pre>{@code
     * this.errorTimestamp = ZonedDateTime.now(DEFAULT_ZONE_ID);
     * }</pre>
     *
     * @see java.time.ZoneId
     * @see java.time.ZonedDateTime
     */
    @Transient
    private static final ZoneId DEFAULT_ZONE_ID = ZoneId.of("CET");

    /**
     * A unique identifier for each database access exception.
     *
     * <p>This ID is represented as a {@link UUID} and is automatically generated by the database
     * using the UUID generation strategy.
     * It serves as the primary key for the {@code DAE} table,
     * ensuring that each exception record is uniquely identifiable.</p>
     *
     * <p><b>Mapping Details:</b></p>
     * <ul>
     *   <li><b>Column Name:</b> {@code dae_id}</li>
     *   <li><b>Constraints:</b> Not null, unique, immutable</li>
     *   <li><b>Generation Strategy:</b> {@link GenerationType#UUID}</li>
     * </ul>
     *
     * @see UUID
     */
    @Id
    @Column(name = "dae_id", unique = true, nullable = false, updatable = false)
    private UUID daeId;

    /**
     * The detailed error message or reason for the exception.
     *
     * <p>This field stores the explanation of the error that occurred during a database operation.
     * It is a mandatory field and aligns with the {@code error_message} column in the database schema.</p>
     *
     * <p><b>Mapping Details:</b></p>
     * <ul>
     *   <li><b>Column Name:</b> {@code error_message}</li>
     *   <li><b>Constraints:</b> Not null</li>
     *   <li><b>Length:</b> Unlimited (as a {@code TEXT} data type)</li>
     * </ul>
     *
     * <p>The value for this field is automatically set when an exception is constructed.</p>
     */
    @Column(name = "error_message", nullable = false)
    private String errorMessage;

    /**
     * The timestamp indicating when the exception occurred.
     *
     * <p>This field is represented as a {@link ZonedDateTime} and leverages the database's
     * timestamp functionality with a default value of the current time during record insertion.</p>
     *
     * <p><b>Mapping Details:</b></p>
     * <ul>
     *   <li><b>Column Name:</b> {@code error_timestamp}</li>
     *   <li><b>Constraints:</b> Not null</li>
     *   <li><b>Data Type:</b> TIMESTAMP</li>
     *   <li><b>Default Value:</b> {@code current_timestamp}</li>
     * </ul>
     *
     * @see ZonedDateTime
     */
    @Column(name = "error_timestamp", nullable = false, columnDefinition = "TIMESTAMPTZ NOT NULL")
    private ZonedDateTime errorTimestamp;

    /**
     * The specific database operation being performed when the error occurred.
     *
     * <p>This field provides context about the type of database operation, such as "INSERT", "UPDATE",
     * or "DELETE", during which the exception occurred.
     * The field is optional, as some exceptions may
     * not be tied to a specific database operation.</p>
     *
     * <p><b>Mapping Details:</b></p>
     * <ul>
     *   <li><b>Column Name:</b> {@code operation}</li>
     *   <li><b>Constraints:</b> Nullable</li>
     *   <li><b>Length:</b> Variable (e.g., VARCHAR(10))</li>
     * </ul>
     */
    @Column(name = "operation")
    private String operation;

    /**
     * The database entity that is most relevant to the exception, if applicable.
     *
     * <p>This field is designed to store the name of the database entity (such as a table or view)
     * involved in the operation where the error occurred.
     * It provides additional context for
     * debugging and analysis of exceptions.</p>
     *
     * <p><b>Mapping Details:</b></p>
     * <ul>
     *   <li><b>Column Name:</b> {@code related_entity}</li>
     *   <li><b>Constraints:</b> Nullable</li>
     *   <li><b>Length:</b> Variable (e.g., VARCHAR(25))</li>
     * </ul>
     */
    @Column(name = "related_entity")
    private String relatedEntity;

    /**
     * The serialized stack trace of the exception's root cause.
     *
     * <p>This field stores the full stack trace of the exception in a serialized format for
     * easier retrieval and analysis of the error.
     * It is an optional field, and its value is
     * set only if the exception has a root cause.</p>
     *
     * <p><b>Mapping Details:</b></p>
     * <ul>
     *   <li><b>Column Name:</b> {@code stack_trace}</li>
     *   <li><b>Constraints:</b> Nullable</li>
     *   <li><b>Data Type:</b> {@code TEXT}</li>
     * </ul>
     *
     * <p>The stack trace is generated and stored using the {@code getStackTrace} method inside the
     * class, which formats the exception's trace dynamically.</p>
     */
    @Column(name = "stack_trace")
    private String stackTrace;

    /**
     * Additional contextual information about the exception, if any.
     *
     * <p>This field stores auxiliary details or metadata related to the exception, such as
     * whether suppression was enabled or other traceable settings during the exception's
     * construction.
     * It provides extensibility for custom exception details.</p>
     *
     * <p><b>Mapping Details:</b></p>
     * <ul>
     *   <li><b>Column Name:</b> {@code additional_info}</li>
     *   <li><b>Constraints:</b> Nullable</li>
     *   <li><b>Data Type:</b> {@code TEXT}</li>
     * </ul>
     */
    @Column(name = "additional_info")
    private String additionalInfo;

    /**
     * The type of this exception, categorized using the {@link TypeOfDAE} enumeration.
     *
     * <p>This field represents the classification of the exception, such as whether it
     * occurred during an "INSERT," "UPDATE," or "DELETE" operation.
     * The type is determined
     * through the {@link TypeOfDAE} enum, which defines a fixed set of possible operations.</p>
     *
     * <p>The default value for this field is {@link TypeOfDAE#GNL} (General), indicating that
     * the exception is not tied to any particular operation type.</p>
     *
     * @see TypeOfDAE
     */
    private TypeOfDAE type;

    /**
     * Constructor required by JPA.
     */
    protected DataAccessException() {
        super();
        this.type = TypeOfDAE.GNL;
    }

    /**
     * Constructs a new {@code DataAccessException} with the specified type and detail message.
     *
     * <p>This constructor is used to initialize an exception instance for a specific database
     * operation failure, characterized by its {@link TypeOfDAE} and a message elaborating the reason.</p>
     *
     * <h3>Key Features:</h3>
     * <ul>
     *     <li>Provides contextual information regarding the database operation and the reason for failure.</li>
     *     <li>Allows categorization of the exception for diagnostics using the {@link TypeOfDAE} enum.</li>
     *     <li>Prepares the exception for logging, debugging, and consistency in error-handling flows.</li>
     * </ul>
     *
     * <h3>Example Usage:</h3>
     * <pre>{@code
     * throw new DataAccessException(TypeOfDAE.INS, "Failed to insert new user to the database");
     * }</pre>
     *
     * <h3>Expected Exceptions:</h3>
     * <ul>
     *     <li>{@link IllegalArgumentException}: Thrown when the provided reason is blank or null.</li>
     * </ul>
     *
     * @param type   The type of operation during which the exception occurred.
     *               This may be {@code null}, in which case the type defaults to {@link TypeOfDAE#GNL}.
     * @param reason A non-empty string providing a descriptive reason for the exception cause.
     * @throws IllegalArgumentException If {@code reason} is null or blank.
     * @see TypeOfDAE
     */
    public DataAccessException(@Nullable TypeOfDAE type, @NotNull String reason) throws IllegalArgumentException {
        this(type, reason, null, false, true);
    }

    /**
     * Constructs a {@code DataAccessException} using a string representation of the database operation type.
     *
     * <p>This constructor performs validation on the input {@code type} string to ensure it corresponds to
     * a valid {@link TypeOfDAE} value.
     * The exception's detailed message is set using the provided {@code reason}.</p>
     *
     * <h3>Validation:</h3>
     * <ul>
     *     <li>The {@code type} string is parsed
     *     using a case-insensitive comparison to match values of the {@link TypeOfDAE} enum.</li>
     *     <li>If parsing fails, an {@link IllegalArgumentException} is thrown to alert invalid input.</li>
     * </ul>
     *
     * <h3>Example Usage:</h3>
     * <pre>{@code
     * try {
     *     throw new DataAccessException("INS", "Failed to insert a record due to constraint violation.");
     * } catch (DataAccessException e) {
     *     e.printStackTrace(); // Will include the reason provided
     * }
     * }</pre>
     *
     * @param type   A string representing the database operation type. Supported values are derived from {@link TypeOfDAE}.
     * @param reason A detailed reason explaining the cause of the exception.
     * @throws IllegalArgumentException If the provided reason is blank or the type is invalid.
     * @see TypeOfDAE
     */
    public DataAccessException(@Nullable String type, @NotNull String reason) throws IllegalArgumentException {
        this(type, reason, null, false, true);
    }

    /**
     * Constructs a {@code DataAccessException} with the specified type, reason, and root cause.
     *
     * <p>This constructor provides additional flexibility by linking the exception to its
     * original {@link Throwable}, enabling full-stack tracing and debugging.</p>
     *
     * <h3>Features:</h3>
     * <ul>
     *     <li>Allows for both contextual information (type, reason) and traceback linkage (cause).</li>
     *     <li>Automatically logs the exception using SLF4J during initialization.</li>
     * </ul>
     *
     * <h3>Example Usage:</h3>
     * <pre>{@code
     * Throwable cause = new SQLTimeoutException("Database timeout occurred.");
     * throw new DataAccessException(TypeOfDAE.FND, "Failed to fetch user data", cause);
     * }</pre>
     *
     * @param type   The database operation type during which the error occurred, defined by {@link TypeOfDAE}.
     * @param reason A non-empty description of the exception cause.
     * @param cause  The original {@link Throwable} that caused this exception.
     * @throws IllegalArgumentException If the {@code reason} is null or blank.
     * @see Throwable
     */
    public DataAccessException(@Nullable TypeOfDAE type, @NotNull String reason, @Nullable Throwable cause) throws IllegalArgumentException {
        this(type, reason, cause, false, true);
    }

    /**
     * Constructs a {@code DataAccessException} with the specified type, reason, and root cause.
     *
     * <p>This constructor provides additional flexibility by linking the exception to its
     * original {@link Throwable}, enabling full-stack tracing and debugging.</p>
     *
     * <h3>Features:</h3>
     * <ul>
     *     <li>Allows for both contextual information (type, reason) and traceback linkage (cause).</li>
     *     <li>Automatically logs the exception using SLF4J during initialization.</li>
     * </ul>
     *
     * <h3>Example Usage:</h3>
     * <pre>{@code
     * Throwable cause = new SQLTimeoutException("Database timeout occurred.");
     * throw new DataAccessException(TypeOfDAE.FND, "Failed to fetch user data", cause);
     * }</pre>
     *
     * @param type   The database operation type during which the error occurred, defined by {@link TypeOfDAE}.
     * @param reason A non-empty description of the exception cause.
     * @param cause  The original {@link Throwable} that caused this exception.
     * @throws IllegalArgumentException If the {@code reason} is null or blank.
     * @see Throwable
     */
    public DataAccessException(@Nullable Object type, @Nullable String reason, @Nullable Throwable cause, boolean enableSuppression, boolean writableStackTrace) throws IllegalArgumentException {
        super(MSG_PREFIX + (reason != null ? reason : ""), cause, enableSuppression, writableStackTrace);
        if (reason != null) checkReason(reason);
        if (type instanceof TypeOfDAE t) this.type = t;
        else if (type instanceof String s) this.type = parseType(s);
        else this.type = TypeOfDAE.GNL;

        this.errorMessage = reason;
        this.errorTimestamp = ZonedDateTime.now(DEFAULT_ZONE_ID);
        this.stackTrace = cause != null ? getStackTrace(cause) : null;
        this.operation = enableSuppression ? "Suppressed" : "Not Suppressed";
        this.relatedEntity = this.getClass().getName();
        this.additionalInfo = writableStackTrace ? "Stack Trace Writable" : "Stack Trace Not Writable";

        LoggerUtil.logWarn("DataAccessException occurred: reason " + reason + " cause " + cause);
        registerException(this.type, reason, cause, enableSuppression, writableStackTrace);
    }

    /**
     * Verifies and validates the provided error reason string.
     *
     * <p>This method ensures that the exception's reason message complies with basic validation
     * rules, such as being non-null and non-blank.
     * Invalid reasons cause the method to throw an
     * {@link IllegalArgumentException}.</p>
     *
     * <h3>Usage:</h3>
     * <pre>{@code
     * try {
     *     checkReason(""); // Will throw an exception
     * } catch (IllegalArgumentException e) {
     *     System.out.println("Invalid reason: " + e.getMessage());
     * }
     * }</pre>
     *
     * @param reason The error reason strings to validate.
     * @throws IllegalArgumentException If {@code reason} is null or blank.
     */
    private void checkReason(@NotNull String reason) throws IllegalArgumentException {
        if (reason.isBlank()) throw new IllegalArgumentException(INVALID_REASON_MSG);
    }

    /**
     * Returns the type of the exception as defined in {@link TypeOfDAE}.
     *
     * @return The {@link TypeOfDAE} representing the exception type.
     */
    public TypeOfDAE getType() {
        return type;
    }

    /**
     * Generates a human-readable stack trace string for the provided {@link Throwable}.
     *
     * <p>This utility extracts each element from the stack trace of the given exception and
     * formats it into a single string, separating each trace element by a newline.</p>
     *
     * <h3>Example:</h3>
     * <pre>{@code
     * try {
     *     throw new RuntimeException("Test exception");
     * } catch (RuntimeException e) {
     *     String trace = getStackTrace(e);
     *     System.out.println(trace); // Prints the stack trace as a single string.
     * }
     * }</pre>
     *
     * @param cause The {@link Throwable} for which to generate the stack trace string.
     * @return A formatted string containing the full stack trace of the provided exception.
     */
    private @NotNull String getStackTrace(@NotNull Throwable cause) {
        StringBuilder sb = new StringBuilder();
        for (StackTraceElement element : cause.getStackTrace()) sb.append(element.toString()).append("\n");
        return sb.toString();
    }

    /**
     * Parses a string into a {@link TypeOfDAE} value.
     *
     * @param type A string representing the type.
     * @return The corresponding {@link TypeOfDAE} value.
     * @throws IllegalArgumentException If the string does not match any valid types.
     */
    private @NotNull TypeOfDAE parseType(@NotNull String type) throws IllegalArgumentException {
        for (TypeOfDAE t : TypeOfDAE.values()) if (t.toString().equalsIgnoreCase(type)) return t;
        throw new IllegalArgumentException(INVALID_TYPE_MSG);
    }

    /**
     * Placeholder method for optionally persisting exceptions in a database or logging context.
     *
     * @param type               The type of exception.
     * @param reason             A descriptive message for the exception.
     * @param cause              The root cause, if available.
     * @param enableSuppression  Whether suppression is enabled.
     * @param writableStackTrace Whether the stack trace is writable.
     */
    private void registerException(@NotNull TypeOfDAE type, @Nullable String reason, @Nullable Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        // TODO: Implement this if persistence is required.
    }
}